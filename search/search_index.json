{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":"<p>a download wrapper with callback</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation are located here</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install git+https://github.com/cupang-afk/cupang-downloader\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from cupang_downloader import Downloader, DownloadJob\nfrom cupang_downloader.downloaders.curl_downloader import CurlDownloader\n\nd = Downloader(CurlDownloader())\njob = DownloadJob(url=\"https://link.testfile.org/bNYZFw\", out=\"10MB.mp4\") \n\nd.dl(job=job)\n</code></pre>"},{"location":"#supported-downloaders","title":"Supported Downloaders","text":"<ul> <li><code>aria2_downloader</code> Uses <code>aria2c</code> to download a file </li> <li><code>curl_downloader</code> Uses <code>curl</code> to download a file</li> <li><code>pycurl_downloader</code> Uses <code>pycurl</code> Python module to download a file (refer to their website for installation instructions)</li> <li><code>requests_downloader</code> Uses <code>requests</code> Python module to download a file</li> <li><code>urllib_downloader</code> Uses built-in <code>urllib.request</code> Python module to download file</li> <li><code>wget_downloader</code> Uses <code>wget</code> to download file </li> </ul> <p>These downloaders are cross-platform, provided the necessary requirements are installed.</p>"},{"location":"#adding-custom-downloaders","title":"Adding Custom Downloaders","text":"<p>If you want to use a downloader not listed above, you can add it yourself.</p> <p>For example, here's how to create a Git downloader</p> <pre><code>\"\"\"Example how to create a git downloader using `git` command\"\"\"\n\nimport os\nimport re\nimport stat\nimport subprocess\nfrom pathlib import Path\nfrom threading import Event\n\nfrom cupang_downloader import DownloaderBase, DownloaderSubprocessMixin\n\n\nclass GitDownloader(DownloaderSubprocessMixin, DownloaderBase):\n    \"\"\"GitDownloader uses `git` to download repositories.\"\"\"\n\n    def __init__(self, git_bin: str | Path = None, cancel_event: Event = None) -&gt; None:\n        \"\"\"\n        Args:\n            git_bin (str | Path, optional): Absolute path to the `git` binary.\n                If None then use system `git`. Defaults to None..\n            cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        \"\"\"\n        self.bin = self.check_bin(git_bin or (\"git\" if os.name != \"nt\" else \"git.exe\"))\n        self.cmd = [str(self.bin), \"clone\", \"--progress\"]\n        self.git_pattern = re.compile(r\"\\((\\d+)/(\\d+)\\)\")  # capture something like (0/177) in clone progress\n        super().__init__(cancel_event, None)\n\n    def _set_permission(self, dir: Path):\n        if not dir.exists():\n            return\n        dir.chmod(stat.S_IWRITE)\n        for file in dir.rglob(\"*\"):\n            file.chmod(stat.S_IWRITE)\n\n    def download(\n        self,\n        job,\n        progress_callback,\n    ) -&gt; None:\n        try:\n            # we run git command using .popen_wrapper\n            with self.popen_wrapper(\n                self.cmd + [job.url, str(job.out.absolute())],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                stdin=None,\n                universal_newlines=True,\n                bufsize=1,\n                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if os.name == \"nt\" else 0,\n            ) as p:\n                while p.poll() is None and not self.is_canceled:\n                    line = p.stdout.readline()\n                    line_lower = line.lower()\n                    if not line:\n                        break\n\n                    # read stdout and use some of its status as progress tracking\n                    #\n                    if \"done\" in line_lower:\n                        # if line has \"done\" then the process is done\n                        continue\n                    #\n                    # the cloning process status\n                    if \"counting objects\" in line_lower:\n                        git_status = \"Counting\"\n                    elif \"compressing objects\" in line_lower:\n                        git_status = \"Compressing\"\n                    elif \"receiving objects\" in line_lower:\n                        git_status = \"Receiving\"\n                    elif \"resolving deltas\" in line_lower:\n                        git_status = \"Resolving\"\n                    elif \"updating files\" in line_lower:\n                        git_status = \"Updating\"\n\n                    # failsafe if there any extra step in cloning progress (usually there isn't)\n                    else:\n                        git_status = \"?\"\n\n                    # find pattern of object being cloned\n                    matches = self.git_pattern.search(line)\n\n                    # the clone is still running but we don't have anything to be report\n                    # so we continue\n                    if not matches:\n                        continue\n\n                    # call the progress_callback\n                    total = int(matches.group(2))\n                    downloaded = int(matches.group(1))\n                    speed = (line.split(\",\")[1:] + [\"\"])[0].strip()\n                    self._handle_progress(\n                        progress_callback,\n                        job,\n                        total,\n                        downloaded,\n                        # extra progress status to be send to the progress_callback\n                        # we can utilize this\n                        git_status=git_status,\n                        git_speed=speed,\n                    )\n        finally:\n            # to obey the shutil.move\n            # we need to add write permission to the cloned folder\n            # sometime it fail to do so when we leave the permission as is\n            self._set_permission(job.out)\n</code></pre>"},{"location":"#usage-example-for-gitdownloader","title":"Usage Example for GitDownloader","text":"<pre><code>from pathlib import Path\n\nfrom cupang_downloader import CupangDownloader, DownloadJob\n\n# git progress callback\ndef git_progress(j: DownloadJob, t: int, d: int, **extra):\n    print(f\"\\r\\033[K{j.progress_name}: {t}/{d} {extra['git_status']} {extra['git_speed']}\", end=\"\", flush=True)\n\n\nb = CupangDownloader(GitDownloader())\nb.dl(\n    DownloadJob(\"https://GITURL\", Path(\"SOMEPROJECT\")),\n    on_progress=git_progress, # add git progress callback\n)\n</code></pre>"},{"location":"#callback","title":"Callback","text":"<p>You can pass custom callback functions to the <code>.dl()</code> function, including:</p> <ul> <li><code>on_start</code></li> <li><code>on_finish</code></li> <li><code>on_progress</code></li> <li><code>on_cancel</code></li> <li><code>on_error</code></li> </ul>"},{"location":"#on_start-on_finish-on_cancel","title":"<code>on_start</code>, <code>on_finish</code>, <code>on_cancel</code>","text":"<p>These callbacks receive one argument: the <code>DownloadJob</code> object.</p> <pre><code>def on_start(job: DownloadJob):\n    print(\"Starting\", job.progress_name)\n</code></pre>"},{"location":"#on_error","title":"<code>on_error</code>","text":"<p>This callback receives two arguments: the <code>DownloadJob</code> object and a tuple containing the exception type, exception instance, and traceback.</p> <pre><code>def on_error(job: DownloadJob, error: tuple[type[BaseException], Exception, TracebackType]):\n    print(\"Something went wrong\", error[1])\n</code></pre>"},{"location":"#on_progress","title":"<code>on_progress</code>","text":"<p>This callback receives four arguments: the <code>DownloadJob</code> object, total file size (<code>int</code>), downloaded file size (<code>int</code>), and additional keyword arguments (<code>extra</code>), which depend on the downloader.</p> <pre><code>def on_progress(job: DownloadJob, total: int, downloaded: int, **extra):\n    print(\"Downloading\", job.progress_name, f\"{total}/{downloaded}\")\n</code></pre> <p>Warning</p> <p><code>on_progress</code> callback should return <code>None</code> otherwise it will raise <code>CallbackNonZeroReturnError</code></p>"},{"location":"#todo","title":"TODO","text":"<ul> <li> fixing stuff</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2024-05-31","title":"[0.1.0] - 2024-05-31","text":""},{"location":"CHANGELOG/#bump","title":"Bump","text":"<ul> <li>Version - -&gt; 0.1.0</li> </ul>"},{"location":"CHANGELOG/#docs","title":"Docs","text":"<ul> <li>Update README.md</li> </ul>"},{"location":"example/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Git Downloader</li> <li>Rich Callback</li> </ul>"},{"location":"example/git_downloader/","title":"Git Downloader","text":"<p>Example <code>git_downloader.py</code></p> <pre><code>\"\"\"Example how to create a git downloader using `git` command\"\"\"\n\nimport os\nimport re\nimport stat\nimport subprocess\nfrom pathlib import Path\nfrom threading import Event\n\nfrom cupang_downloader import DownloaderBase, DownloaderSubprocessMixin\n\n\nclass GitDownloader(DownloaderSubprocessMixin, DownloaderBase):\n    \"\"\"GitDownloader uses `git` to download repositories.\"\"\"\n\n    def __init__(self, git_bin: str | Path = None, cancel_event: Event = None) -&gt; None:\n        \"\"\"\n        Args:\n            git_bin (str | Path, optional): Absolute path to the `git` binary.\n                If None then use system `git`. Defaults to None..\n            cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        \"\"\"\n        self.bin = self.check_bin(git_bin or (\"git\" if os.name != \"nt\" else \"git.exe\"))\n        self.cmd = [str(self.bin), \"clone\", \"--progress\"]\n        self.git_pattern = re.compile(r\"\\((\\d+)/(\\d+)\\)\")  # capture something like (0/177) in clone progress\n        super().__init__(cancel_event, None)\n\n    def _set_permission(self, dir: Path):\n        if not dir.exists():\n            return\n        dir.chmod(stat.S_IWRITE)\n        for file in dir.rglob(\"*\"):\n            file.chmod(stat.S_IWRITE)\n\n    def download(\n        self,\n        job,\n        progress_callback,\n    ) -&gt; None:\n        try:\n            # we run git command using .popen_wrapper\n            with self.popen_wrapper(\n                self.cmd + [job.url, str(job.out.absolute())],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n                stdin=None,\n                universal_newlines=True,\n                bufsize=1,\n                creationflags=subprocess.CREATE_NEW_PROCESS_GROUP if os.name == \"nt\" else 0,\n            ) as p:\n                while p.poll() is None and not self.is_canceled:\n                    line = p.stdout.readline()\n                    line_lower = line.lower()\n                    if not line:\n                        break\n\n                    # read stdout and use some of its status as progress tracking\n                    #\n                    if \"done\" in line_lower:\n                        # if line has \"done\" then the process is done\n                        continue\n                    #\n                    # the cloning process status\n                    if \"counting objects\" in line_lower:\n                        git_status = \"Counting\"\n                    elif \"compressing objects\" in line_lower:\n                        git_status = \"Compressing\"\n                    elif \"receiving objects\" in line_lower:\n                        git_status = \"Receiving\"\n                    elif \"resolving deltas\" in line_lower:\n                        git_status = \"Resolving\"\n                    elif \"updating files\" in line_lower:\n                        git_status = \"Updating\"\n\n                    # failsafe if there any extra step in cloning progress (usually there isn't)\n                    else:\n                        git_status = \"?\"\n\n                    # find pattern of object being cloned\n                    matches = self.git_pattern.search(line)\n\n                    # the clone is still running but we don't have anything to be report\n                    # so we continue\n                    if not matches:\n                        continue\n\n                    # call the progress_callback\n                    total = int(matches.group(2))\n                    downloaded = int(matches.group(1))\n                    speed = (line.split(\",\")[1:] + [\"\"])[0].strip()\n                    self._handle_progress(\n                        progress_callback,\n                        job,\n                        total,\n                        downloaded,\n                        # extra progress status to be send to the progress_callback\n                        # we can utilize this\n                        git_status=git_status,\n                        git_speed=speed,\n                    )\n        finally:\n            # to obey the shutil.move\n            # we need to add write permission to the cloned folder\n            # sometime it fail to do so when we leave the permission as is\n            self._set_permission(job.out)\n</code></pre>"},{"location":"example/rich_callback/","title":"Rich Callback","text":"<p>Example <code>rich_callback.py</code></p> <pre><code>\"\"\"Example of how to use download callback using `rich.progress`\"\"\"\n\nfrom threading import Lock\n\nfrom cupang_downloader import Downloader, DownloadJob\nfrom cupang_downloader.downloaders.curl_downloader import CurlDownloader\nfrom rich.progress import Progress, SpinnerColumn, TaskID, TransferSpeedColumn\nfrom rich.traceback import Traceback\n\nc = Downloader(CurlDownloader())  # any downloader\n\nwith Progress(SpinnerColumn(), *Progress.get_default_columns(), TransferSpeedColumn()) as pp:\n    # save any running progress bar\n    # so we can take it in our callback function\n    progresses: dict[str, TaskID] = {}\n    progresses_lock = Lock()\n\n    # create an unique id\n    # we utilize the DownloadJob object and retrive its memory id\n    # and convert it to hex\n    def create_unique_id(o):\n        return hex(id(o))\n\n    # remove the progress bar when download is finished, canceled, or error\n    def remove_bar(k: str):\n        pp.update(progresses[k], visible=False)\n        pp.remove_task(progresses[k])\n        # using lock we can now remove the progress from dictionary\n        # by using lock, we ensure that only one thread can edit the dictionary\n        with progresses_lock:\n            del progresses[k]\n\n    def _on_start(j: DownloadJob):\n        k = create_unique_id(j)\n        # create new progress bar and save to progresses\n        progresses[k] = pp.add_task(description=j.progress_name, total=None, visible=False)\n\n    def _on_finish(j: DownloadJob):\n        pp.print(\"Finished\", j.progress_name)\n        k = create_unique_id(j)\n        remove_bar(k)\n\n    def _on_progress(j: DownloadJob, t: int, d: int, **extra):\n        k = create_unique_id(j)\n        # we set to None because rich.progress has pulse animation when total is None\n        t = None if t == 0 else t\n        pp.update(progresses[k], total=t, completed=d, visible=True)\n\n    def _on_cancel(j: DownloadJob):\n        pp.print(\"Canceled\", j.progress_name)\n        k = create_unique_id(j)\n        remove_bar(k)\n\n    def _on_error(j: DownloadJob, err):\n        pp.print(\"Error while downloading\", j.progress_name, Traceback(Traceback.extract(*err)))\n        k = create_unique_id(j)\n        remove_bar(k)\n\n    # download\n    result = c.dl(\n        DownloadJob(\"https://link.testfile.org/aXCg7h\", \"out.mp4\"),  # 11MB\n        on_start=_on_start,\n        on_finish=_on_finish,\n        on_progress=_on_progress,\n        on_cancel=_on_cancel,\n        on_error=_on_error,\n    )\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cupang_downloader<ul> <li>downloader</li> <li>downloaders<ul> <li>aria2_downloader</li> <li>base</li> <li>curl_downloader</li> <li>pycurl_downloader</li> <li>requests_downloader</li> <li>urllib_downloader</li> <li>wget_downloader</li> </ul> </li> <li>error</li> <li>job</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/cupang_downloader/downloader/","title":"downloader","text":""},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.Downloader","title":"Downloader","text":"<pre><code>Downloader(downloader)\n</code></pre> <p>The Downloader</p> PARAMETER DESCRIPTION <code>downloader</code> <p>The downloader to be used.</p> <p> TYPE: <code>DownloaderBase</code> </p> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def __init__(self, downloader: DownloaderBase):\n    \"\"\"\n    Args:\n        downloader (DownloaderBase): The downloader to be used.\n    \"\"\"\n    if not isinstance(downloader, DownloaderBase):\n        raise TypeError(f\"{downloader} is not a subclass of DownloaderBase\")\n    self._downloader = downloader\n</code></pre>"},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.Downloader.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Cancel the ongoing download.</p> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def cancel(self):\n    \"\"\"\n    Cancel the ongoing download.\n    \"\"\"\n    self._downloader.cancel_event.set()\n</code></pre>"},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.Downloader.reset_cancel","title":"reset_cancel","text":"<pre><code>reset_cancel()\n</code></pre> <p>Reset the cancellation event.</p> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def reset_cancel(self):\n    \"\"\"\n    Reset the cancellation event.\n    \"\"\"\n    self._downloader.cancel_event.clear()\n</code></pre>"},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.Downloader.dl","title":"dl","text":"<pre><code>dl(\n    job,\n    *,\n    overwrite=True,\n    on_start=None,\n    on_finish=None,\n    on_progress=None,\n    on_cancel=None,\n    on_error=None\n)\n</code></pre> <p>Download a file.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>overwrite</code> <p>Whether to allow existing files to be overwritten. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>on_start</code> <p>Callback for when the download starts. Defaults to None.</p> <p> TYPE: <code>_StartCallback</code> DEFAULT: <code>None</code> </p> <code>on_finish</code> <p>Callback for when the download finishes. Defaults to None.</p> <p> TYPE: <code>_FinishCallback</code> DEFAULT: <code>None</code> </p> <code>on_progress</code> <p>Callback for download progress updates. Defaults to None.</p> <p> TYPE: <code>_ProgressCallback</code> DEFAULT: <code>None</code> </p> <code>on_cancel</code> <p>Callback for when the download is cancelled. Defaults to None.</p> <p> TYPE: <code>_CancelCallback</code> DEFAULT: <code>None</code> </p> <code>on_error</code> <p>Callback for when an error occurs. Defaults to None.</p> <p> TYPE: <code>_ErrorCallback</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Path | IO[bytes] | None</code> <p>Path | IO[bytes] | None: The path to the downloaded file, or the downloaded content if no output path is specified, or None if download is fail or canceled.</p> RAISES DESCRIPTION <code>DownloadError</code> <p>If no on_error callback is provided, this error is raised with a message indicating an issue occurred during the download.</p> Notes <ul> <li>If overwrite is False then job.out will be renamed to non-exists Path (only when job.out is a Path).</li> <li>If a callback (on_start, on_finish, on_progress, etc.) is None, the default callback will be used.   If you do not want to use a callback, set it to False.</li> </ul> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def dl(\n    self,\n    job: DownloadJob,\n    *,\n    overwrite=True,\n    on_start: _StartCallback = None,\n    on_finish: _FinishCallback = None,\n    on_progress: _ProgressCallback = None,\n    on_cancel: _CancelCallback = None,\n    on_error: _ErrorCallback = None,\n) -&gt; Path | IO[bytes] | None:\n    \"\"\"\n    Download a file.\n\n    Args:\n        job (DownloadJob): The download job.\n        overwrite (bool, optional): Whether to allow existing files to be overwritten. Defaults to True.\n        on_start (_StartCallback, optional): Callback for when the download starts. Defaults to None.\n        on_finish (_FinishCallback, optional): Callback for when the download finishes. Defaults to None.\n        on_progress (_ProgressCallback, optional): Callback for download progress updates. Defaults to None.\n        on_cancel (_CancelCallback, optional): Callback for when the download is cancelled. Defaults to None.\n        on_error (_ErrorCallback, optional): Callback for when an error occurs. Defaults to None.\n\n    Returns:\n        Path | IO[bytes] | None: The path to the downloaded file,\n            or the downloaded content if no output path is specified,\n            or None if download is fail or canceled.\n\n    Raises:\n        DownloadError: If no on_error callback is provided, this error is raised with a\n            message indicating an issue occurred during the download.\n\n    Notes:\n        - If overwrite is False then job.out will be renamed to non-exists Path (only when job.out is a Path).\n        - If a callback (on_start, on_finish, on_progress, etc.) is None, the default callback will be used.\n          If you do not want to use a callback, set it to False.\n    \"\"\"\n    job = job.copy_with_new_value(\n        out=self._handle_out(job.out, overwrite), headers=self._handle_headers(job.headers)\n    )\n    if isinstance(job.out, Path):\n        tmp_dir = job.out.parent\n        tmp_prefix, _ = remove_suffix(job.out)\n    else:\n        tmp_dir = None\n        tmp_prefix = \"dltemp_\"\n    with temppath(dir=tmp_dir, prefix=tmp_prefix) as tmp:\n        log.debug(f\"set tmp download file of {job.url} to {tmp}\")\n        result = self._dl(\n            job,\n            tmp,\n            on_start=_on_start if on_start is None else on_start,\n            on_finish=_on_finish if on_finish is None else on_finish,\n            on_progress=_on_progress if on_progress is None else on_progress,\n            on_cancel=_on_cancel if on_cancel is None else on_cancel,\n            on_error=_on_error if on_error is None else on_error,\n        )\n        return self._handle_result(result, job.out)\n</code></pre>"},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.Downloader.batch_dl","title":"batch_dl","text":"<pre><code>batch_dl(\n    jobs,\n    *,\n    overwrite=True,\n    max_download=5,\n    on_start=None,\n    on_finish=None,\n    on_progress=None,\n    on_cancel=None,\n    on_error=None\n)\n</code></pre> <p>Download multiple files concurrently.</p> PARAMETER DESCRIPTION <code>jobs</code> <p>List of download jobs.</p> <p> TYPE: <code>list[DownloadJob]</code> </p> <code>overwrite</code> <p>Whether to allow existing files to be overwritten. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>max_download</code> <p>Maximum number of concurrent downloads. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5</code> </p> <code>on_start</code> <p>Callback for when the download starts. Defaults to None.</p> <p> TYPE: <code>_StartCallback</code> DEFAULT: <code>None</code> </p> <code>on_finish</code> <p>Callback for when the download finishes. Defaults to None.</p> <p> TYPE: <code>_FinishCallback</code> DEFAULT: <code>None</code> </p> <code>on_progress</code> <p>Callback for download progress updates. Defaults to None.</p> <p> TYPE: <code>_ProgressCallback</code> DEFAULT: <code>None</code> </p> <code>on_cancel</code> <p>Callback for when the download is cancelled. Defaults to None.</p> <p> TYPE: <code>_CancelCallback</code> DEFAULT: <code>None</code> </p> <code>on_error</code> <p>Callback for when an error occurs. Defaults to None.</p> <p> TYPE: <code>_ErrorCallback</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple[list[Path | IO[bytes] | None], list[BaseException | None]]</code> <p>tuple[list[Path | IO[bytes] | None], list[BaseException | None]]: A tuple containing two lists: - The first list contains the paths to the downloaded files,   or the downloaded content if no output path is specified,   or None if the download failed or was cancelled. - The second list contains any exceptions that were raised during the downloads,   or None if no exceptions were raised.</p> Notes <ul> <li>This function will block your thread and wait until it finished.</li> <li>If overwrite is False then job.out will be renamed to non-exists Path (only when job.out is a Path).</li> <li>If a callback (on_start, on_finish, on_progress, etc.) is None, the default callback will be used.   If you do not want to use a callback, set it to False.</li> <li>The returned lists are guaranteed to be in the same order as the jobs.</li> </ul> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def batch_dl(\n    self,\n    jobs: list[DownloadJob],\n    *,\n    overwrite: bool = True,\n    max_download: int = 5,\n    on_start: _StartCallback = None,\n    on_finish: _FinishCallback = None,\n    on_progress: _ProgressCallback = None,\n    on_cancel: _CancelCallback = None,\n    on_error: _ErrorCallback = None,\n) -&gt; tuple[list[Path | IO[bytes] | None], list[BaseException | None]]:\n    \"\"\"\n    Download multiple files concurrently.\n\n    Args:\n        jobs (list[DownloadJob]): List of download jobs.\n        overwrite (bool, optional): Whether to allow existing files to be overwritten. Defaults to True.\n        max_download (int, optional): Maximum number of concurrent downloads. Defaults to 5.\n        on_start (_StartCallback, optional): Callback for when the download starts. Defaults to None.\n        on_finish (_FinishCallback, optional): Callback for when the download finishes. Defaults to None.\n        on_progress (_ProgressCallback, optional): Callback for download progress updates. Defaults to None.\n        on_cancel (_CancelCallback, optional): Callback for when the download is cancelled. Defaults to None.\n        on_error (_ErrorCallback, optional): Callback for when an error occurs. Defaults to None.\n\n    Returns:\n        tuple[list[Path | IO[bytes] | None], list[BaseException | None]]:\n            A tuple containing two lists:\n            - The first list contains the paths to the downloaded files,\n              or the downloaded content if no output path is specified,\n              or None if the download failed or was cancelled.\n            - The second list contains any exceptions that were raised during the downloads,\n              or None if no exceptions were raised.\n\n    Notes:\n        - This function will block your thread and wait until it finished.\n        - If overwrite is False then job.out will be renamed to non-exists Path (only when job.out is a Path).\n        - If a callback (on_start, on_finish, on_progress, etc.) is None, the default callback will be used.\n          If you do not want to use a callback, set it to False.\n        - The returned lists are guaranteed to be in the same order as the jobs.\n    \"\"\"\n\n    def _dl_worker(job: DownloadJob):\n        job = job.copy_with_new_value(\n            out=self._handle_out(job.out, overwrite),\n            headers=self._handle_headers(job.headers),\n        )\n        if isinstance(job.out, Path):\n            tmp_dir = job.out.parent\n            tmp_prefix, _ = remove_suffix(job.out)\n        else:\n            tmp_dir = None\n            tmp_prefix = \"dltemp_\"\n        with temppath(dir=tmp_dir, prefix=tmp_prefix) as tmp:\n            result = self._dl(\n                job,\n                tmp,\n                on_start=_on_start if on_start is None else on_start,\n                on_finish=_on_finish if on_finish is None else on_finish,\n                on_progress=on_progress,  # no default progress_callback for batch download\n                on_cancel=_on_cancel if on_cancel is None else on_cancel,\n                on_error=_on_error if on_error is None else on_error,\n                _with_pre=False,\n                _with_post=False,\n            )\n            return self._handle_result(result, job.out)\n\n    try:\n        self._downloader.__pre_download__()\n        with ThreadPoolExecutor(max_download) as t:\n            download_jobs = [t.submit(_dl_worker, job) for job in jobs]\n\n            # wait\n            try:\n                while not all([j.done() for j in download_jobs]):\n                    time.sleep(1)\n            except KeyboardInterrupt:\n                self.cancel()\n            finally:\n                t.shutdown(wait=True, cancel_futures=True)\n                self.reset_cancel()\n            res = [r.result() if (not r.cancelled() and r.exception() is None) else None for r in download_jobs]\n            exc = [r.exception() if not r.cancelled() else None for r in download_jobs]\n            return res, exc\n    finally:\n        self._downloader.__post_download__()\n</code></pre>"},{"location":"reference/cupang_downloader/downloader/#cupang_downloader.downloader.filesize","title":"filesize","text":"<pre><code>filesize(\n    size,\n    base=1024,\n    decimal=2,\n    units=[\" bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"],\n)\n</code></pre> <p>Returns a human readable string representation of bytes</p> Source code in <code>src\\cupang_downloader\\downloader.py</code> <pre><code>def filesize(\n    size: float,\n    base: float = 1024,\n    decimal: int = 2,\n    units: list[str] = [\" bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"],\n):\n    \"\"\"Returns a human readable string representation of bytes\"\"\"\n    return f\"{size:,.{decimal}f}{units[0]}\" if size &lt; base else filesize(size / base, base, decimal, units[1:])\n</code></pre>"},{"location":"reference/cupang_downloader/error/","title":"error","text":""},{"location":"reference/cupang_downloader/error/#cupang_downloader.error.BinaryNotFoundError","title":"BinaryNotFoundError","text":"<pre><code>BinaryNotFoundError(bin)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised when a required binary is not found in the system PATH.</p> ATTRIBUTE DESCRIPTION <code>bin</code> <p>The name of the binary that was not found.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src\\cupang_downloader\\error.py</code> <pre><code>def __init__(self, bin: str):\n    self.bin = bin\n</code></pre>"},{"location":"reference/cupang_downloader/error/#cupang_downloader.error.CallbackNonZeroReturnError","title":"CallbackNonZeroReturnError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a callback returns a non-zero value.</p>"},{"location":"reference/cupang_downloader/error/#cupang_downloader.error.DownloadError","title":"DownloadError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors occurring during the download process.</p>"},{"location":"reference/cupang_downloader/job/","title":"job","text":""},{"location":"reference/cupang_downloader/job/#cupang_downloader.job.DownloadJob","title":"DownloadJob  <code>dataclass</code>","text":"<pre><code>DownloadJob(\n    url,\n    out=None,\n    headers=None,\n    progress_name=None,\n    extra=None,\n)\n</code></pre> <p>A class to contain anything related to the download.</p> ATTRIBUTE DESCRIPTION <code>url</code> <p>The URL of the file to be downloaded.</p> <p> TYPE: <code>str</code> </p> <code>out</code> <p>The output stream or path where the downloaded file will be saved. If this is <code>str</code> will try to convert to <code>pathlib.Path</code> Defaults to None.</p> <p> TYPE: <code>IO[bytes] | Path | str | None</code> </p> <code>headers</code> <p>Optional headers to include in the download request. Defaults to None.</p> <p> TYPE: <code>dict[str, str] | None</code> </p> <code>progress_name</code> <p>The name to be used for displaying progress. If not set, then will try to use <code>out.name</code> or <code>url</code> instead. Defaults to None.</p> <p> TYPE: <code>str</code> </p> <code>extra</code> <p>Any additional data associated with the download job. Defaults to None.</p> <p> TYPE: <code>dict[str, Any] | None</code> </p>"},{"location":"reference/cupang_downloader/utils/","title":"utils","text":""},{"location":"reference/cupang_downloader/utils/#cupang_downloader.utils.temppath","title":"temppath","text":"<pre><code>temppath(dir=None, prefix=None, suffix=None, delete=True)\n</code></pre> <p>Context manager for creating temporary files or directories.</p> PARAMETER DESCRIPTION <code>dir</code> <p>The directory where the temporary file or directory will be created. If None, the system default temporary directory will be used. Defaults to None.</p> <p> TYPE: <code>_StrOrPath</code> DEFAULT: <code>None</code> </p> <code>prefix</code> <p>Prefix to be added to the temporary file or directory name. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>suffix</code> <p>Suffix to be added to the temporary file or directory name. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>delete</code> <p>If True, the temporary file or directory will be deleted after use. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> YIELDS DESCRIPTION <code>Path</code> <p>The path to the created temporary file or directory.</p> Source code in <code>src\\cupang_downloader\\utils.py</code> <pre><code>@contextmanager\ndef temppath(\n    dir: _StrOrPath = None,\n    prefix: str = None,\n    suffix: str = None,\n    delete: bool = True,\n):\n    \"\"\"\n    Context manager for creating temporary files or directories.\n\n    Args:\n        dir (_StrOrPath, optional): The directory where the temporary file or directory will be created.\n            If None, the system default temporary directory will be used. Defaults to None.\n        prefix (str, optional): Prefix to be added to the temporary file or directory name. Defaults to None.\n        suffix (str, optional): Suffix to be added to the temporary file or directory name. Defaults to None.\n        delete (bool, optional): If True, the temporary file or directory will be deleted after use. Defaults to True.\n\n    Yields:\n        (Path): The path to the created temporary file or directory.\n    \"\"\"\n    name_template = \"{prefix}{randomname}{suffix}\"\n\n    dir = Path(dir or tempfile.gettempdir()).absolute()\n    while True:\n        tmp = dir / name_template.format(\n            prefix=prefix or \"tmp\",\n            randomname=\"\".join(\n                random.choices(string.ascii_letters, k=10),\n            ),\n            suffix=suffix or \"\",\n        )\n        if not tmp.exists():\n            break\n\n    try:\n        yield tmp\n    finally:\n        if delete:\n            if tmp.is_file():\n                tmp.unlink(missing_ok=True)\n            else:\n                shutil.rmtree(tmp.absolute(), ignore_errors=True)\n</code></pre>"},{"location":"reference/cupang_downloader/utils/#cupang_downloader.utils.request","title":"request","text":"<pre><code>request(url, *, method='GET', headers=None, **kwargs)\n</code></pre> <p>A wrapper for <code>urllib.request.urlopen</code> module with common configurations.</p> PARAMETER DESCRIPTION <code>url</code> <p>The URL to send the request to.</p> <p> TYPE: <code>str</code> </p> <code>method</code> <p>The HTTP method to use, e.g., \"GET\" or \"POST\". Defaults to \"GET\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'GET'</code> </p> <code>headers</code> <p>A dictionary of HTTP headers to send with the request. Defaults to None.</p> <p> TYPE: <code>dict[str, str]</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>HTTPResponse</code> <p>The response object received after making the request.</p> Source code in <code>src\\cupang_downloader\\utils.py</code> <pre><code>@contextmanager\ndef request(\n    url: str,\n    *,\n    method: str = \"GET\",\n    headers: dict[str, str] = None,\n    **kwargs,\n):\n    \"\"\"\n    A wrapper for `urllib.request.urlopen` module with common configurations.\n\n    Args:\n        url (str): The URL to send the request to.\n        method (str, optional): The HTTP method to use, e.g., \"GET\" or \"POST\". Defaults to \"GET\".\n        headers (dict[str, str], optional): A dictionary of HTTP headers to send with the request. Defaults to None.\n\n    Yields:\n        (HTTPResponse): The response object received after making the request.\n    \"\"\"\n    if headers is None:\n        headers = default_headers.copy()\n    else:\n        headers = {**default_headers, **headers}\n\n    req = urllib.request.Request(url, method=method, headers=headers, **kwargs)\n    with urllib.request.urlopen(req, context=default_urllib_context) as res:\n        res = cast(HTTPResponse, res)\n        yield res\n    return res\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/aria2_downloader/","title":"aria2_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/aria2_downloader/#cupang_downloader.downloaders.aria2_downloader.Aria2Downloader","title":"Aria2Downloader","text":"<pre><code>Aria2Downloader(\n    aria2c_bin=None,\n    max_download=999,\n    aria2_token=\"A\",\n    cancel_event=None,\n)\n</code></pre> <p>               Bases: <code>DownloaderSubprocessMixin</code>, <code>DownloaderBase</code></p> <p>Aria2Downloader uses <code>aria2c</code> to download files.</p> PARAMETER DESCRIPTION <code>aria2c_bin</code> <p>Absolute path to the <code>aria2c</code> binary. If None then use system <code>aria2c</code>. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>max_download</code> <p>Maximum number of concurrent downloads. Defaults to 999.</p> <p> TYPE: <code>int</code> DEFAULT: <code>999</code> </p> <code>aria2_token</code> <p>Token for Aria2 RPC. Defaults to \"A\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'A'</code> </p> <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BinaryNotFoundError</code> <p>If the <code>aria2c</code> binary is not found.</p> Source code in <code>src\\cupang_downloader\\downloaders\\aria2_downloader.py</code> <pre><code>def __init__(\n    self,\n    aria2c_bin: str | Path = None,\n    max_download: int = 999,\n    aria2_token: str = \"A\",\n    cancel_event: Event = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        aria2c_bin (str, optional): Absolute path to the `aria2c` binary.\n            If None then use system `aria2c`. Defaults to None.\n        max_download (int, optional): Maximum number of concurrent downloads. Defaults to 999.\n        aria2_token (str, optional): Token for Aria2 RPC. Defaults to \"A\".\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n\n    Raises:\n        BinaryNotFoundError: If the `aria2c` binary is not found.\n    \"\"\"\n    self.bin = self.check_bin(aria2c_bin or (\"aria2c\" if os.name != \"nt\" else \"aria2c.exe\"))\n    self.max_download = max_download\n    self._running = None\n    self.aria2 = None\n    self.aria2_secret = aria2_token\n    self.aria2_token = f\"token:{self.aria2_secret}\"\n    self.aria2_lock = ARIA2_LOCK\n    super().__init__(cancel_event)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/aria2_downloader/#cupang_downloader.downloaders.aria2_downloader.Aria2Downloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\aria2_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_canceled:\n        return\n\n    with self.request(job.url, headers=job.headers) as res:\n        total = int(res.getheader(\"Content-Length\", 0))\n\n    try:\n        with self.aria2_lock:\n            gid = self.aria2.aria2.addUri(\n                self.aria2_token,\n                [job.url],\n                {\n                    \"dir\": str(job.out.parent),\n                    \"out\": job.out.name,\n                    \"allow-overwrite\": \"true\",\n                    \"headers\": [f\"{k}: {v}\" for k, v in {**job.headers}.items()],\n                },\n            )\n        while not self.is_canceled:\n            with self.aria2_lock:\n                try:\n                    status = self._aria_tell_status(\n                        gid, \"status\", \"completedLength\", \"errorMessage\", ttl_hash=_get_ttl_hash(1)\n                    )\n                except (BaseException, Exception):\n                    continue\n\n            if status.get(\"status\", None) != \"active\":\n                break\n\n            downloaded = int(status.get(\"completedLength\", 0))\n            self._handle_progress(progress_callback, job, total, downloaded)\n\n    finally:\n        try:\n            with self.aria2_lock:\n                if status.get(\"status\", None) == \"active\":\n                    self.aria2.aria2.remove(self.aria2_token, gid)\n                self.aria2.aria2.removeDownloadResult(self.aria2_token, gid)\n        except (BaseException, Exception):\n            pass\n        job.out.with_name(job.out.name + \".aria2\").unlink(missing_ok=True)\n        if status and status.get(\"status\", None) == \"error\":\n            raise Aria2Error(status.get(\"errorMessage\", \"There is an error in Aria2 but unknown\"))\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/","title":"base","text":""},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase","title":"DownloaderBase","text":"<pre><code>DownloaderBase(cancel_event=None, chunk_size=None)\n</code></pre> <p>A base class for downloader classes.</p> Notes <ul> <li>Subclasses must implement their own <code>.download()</code> method.</li> <li>If you define an <code>.__init__()</code> method in a subclass, you must call <code>super().__init__()</code>.</li> <li>The <code>.__pre_download()</code> and <code>.__post_download()</code> methods are optional   and only needed if preparation or cleanup is required for your downloader.</li> </ul> Some tips <ul> <li>Use the <code>._handle_progress()</code> method for calling <code>progress_callback</code>.</li> <li>The <code>._log</code> attribute is available for verbose logging, although its use is optional.</li> </ul> PARAMETER DESCRIPTION <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __init__(self, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.cancel_event = cancel_event or Event()\n    self.chunk_size = chunk_size or 8192\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase._log","title":"_log  <code>property</code>","text":"<pre><code>_log\n</code></pre> <p>A Logger instance of this module</p>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase.is_canceled","title":"is_canceled  <code>property</code>","text":"<pre><code>is_canceled\n</code></pre> <p>Check if <code>.cancel_event</code> is set</p>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase.request","title":"request  <code>property</code>","text":"<pre><code>request\n</code></pre> <p>A request wrapper</p> See Also <ul> <li>cupang_downloader.utils.request</li> </ul>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase._handle_progress","title":"_handle_progress","text":"<pre><code>_handle_progress(\n    progress_callback, job, total, downloaded, **extra\n)\n</code></pre> <p>Handle progress callback</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>@final\ndef _handle_progress(\n    self,\n    progress_callback,\n    job: DownloadJob,\n    total: TotalInt,\n    downloaded: DownloadedInt,\n    **extra,\n) -&gt; None:\n    \"\"\"Handle progress callback\"\"\"\n    if not callable(progress_callback):\n        return\n    if progress_callback(job, total, downloaded, **extra) is not None:\n        raise CallbackNonZeroReturnError\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase.__pre_download__","title":"__pre_download__","text":"<pre><code>__pre_download__()\n</code></pre> <p>Prepare downloader</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __pre_download__(self) -&gt; None:\n    \"\"\"Prepare downloader\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase.__post_download__","title":"__post_download__","text":"<pre><code>__post_download__()\n</code></pre> <p>Cleanup downloader</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __post_download__(self) -&gt; None:\n    \"\"\"Cleanup downloader\"\"\"\n    ...\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderBase.download","title":"download  <code>abstractmethod</code>","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>@abstractmethod\ndef download(\n    self,\n    job: DownloadJob,\n    progress_callback: Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any],\n) -&gt; None:\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderSubprocessMixin","title":"DownloaderSubprocessMixin","text":"<p>A Mixin class that can help if the downloader utilize external command.</p>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderSubprocessMixin.check_bin","title":"check_bin","text":"<pre><code>check_bin(bin)\n</code></pre> <p>Check if the binary is available in the system.</p> PARAMETER DESCRIPTION <code>bin</code> <p>The name or absolute path of the binary to check.</p> <p> TYPE: <code>str | Path</code> </p> RAISES DESCRIPTION <code>BinaryNotFoundError</code> <p>If the binary is not found in PATH.</p> <code>FileNotFoundError</code> <p>If the binary is an absolute path and file not exists.</p> RETURNS DESCRIPTION <code>Path</code> <p>The absolute path of the binary if it is found.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>@final\ndef check_bin(self, bin: str | Path) -&gt; Path:\n    \"\"\"\n    Check if the binary is available in the system.\n\n    Args:\n        bin (str | Path): The name or absolute path of the binary to check.\n\n    Raises:\n        BinaryNotFoundError: If the binary is not found in PATH.\n        FileNotFoundError: If the binary is an absolute path and file not exists.\n\n    Returns:\n        Path: The absolute path of the binary if it is found.\n    \"\"\"\n    bin = bin if isinstance(bin, Path) else Path(bin)\n    if bin.is_absolute():\n        if not bin.is_file():\n            raise FileNotFoundError(str(bin))\n        return bin.absolute()\n    else:\n        bin_from_path = shutil.which(str(bin))\n        if not bin_from_path:\n            raise BinaryNotFoundError(str(bin))\n        return Path(bin_from_path).absolute()\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderSubprocessMixin.popen_wrapper","title":"popen_wrapper","text":"<pre><code>popen_wrapper(\n    command, *, raise_nonzero_return=False, **popen_kwargs\n)\n</code></pre> <p>A context manager for subprocess.Popen.</p> <p>This wrapper will try to terminate the process when we leave the <code>with</code> block.</p> <p>by default <code>stdout</code>, <code>stderr</code>, and <code>stdin</code> are filled with subprocess.PIPE. if you need to disable some, you should pass it as None</p> PARAMETER DESCRIPTION <code>command</code> <p>The command to execute.</p> <p> TYPE: <code>list[str]</code> </p> <code>raise_nonzero_return</code> <p>Whether to raise an exception if the command returns a non-zero exit code. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>CalledProcessError</code> <p>If the process returns a non-zero exit code and raise_nonzero_return is True.</p> YIELDS DESCRIPTION <code>Popen</code> <p>The Popen object representing the running process.</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>@contextmanager\ndef popen_wrapper(self, command: list[str], *, raise_nonzero_return=False, **popen_kwargs):\n    \"\"\"\n    A context manager for subprocess.Popen.\n\n    This wrapper will try to terminate the process when we leave the `with` block.\n\n    by default `stdout`, `stderr`, and `stdin` are filled with subprocess.PIPE.\n    if you need to disable some, you should pass it as None\n\n    Args:\n        command (list[str]): The command to execute.\n        raise_nonzero_return (bool, optional): Whether to raise an exception\n            if the command returns a non-zero exit code. Defaults to False.\n\n    Raises:\n        subprocess.CalledProcessError: If the process returns a non-zero exit code\n            and raise_nonzero_return is True.\n\n    Yields:\n        (subprocess.Popen): The Popen object representing the running process.\n    \"\"\"\n\n    if \"stdout\" not in popen_kwargs:\n        popen_kwargs[\"stdout\"] = subprocess.PIPE\n    if \"stderr\" not in popen_kwargs:\n        popen_kwargs[\"stderr\"] = subprocess.PIPE\n    if \"stdin\" not in popen_kwargs:\n        popen_kwargs[\"stdin\"] = subprocess.PIPE\n\n    try:\n        p = subprocess.Popen(command, **popen_kwargs)\n        yield p\n    finally:\n        self.popen_terminate(p, raise_nonzero_return)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/base/#cupang_downloader.downloaders.base.DownloaderSubprocessMixin.popen_terminate","title":"popen_terminate","text":"<pre><code>popen_terminate(p, raise_nonzero_return=True)\n</code></pre> <p>Terminate a subprocess.</p> PARAMETER DESCRIPTION <code>p</code> <p>The subprocess to terminate.</p> <p> TYPE: <code>Popen</code> </p> <code>raise_nonzero_return</code> <p>Whether to raise an exception if the process returns a non-zero exit code. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>CalledProcessError</code> <p>If the process returns a non-zero exit code and raise_nonzero_return is True.</p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def popen_terminate(self, p: subprocess.Popen, raise_nonzero_return=True):\n    \"\"\"\n    Terminate a subprocess.\n\n    Args:\n        p (subprocess.Popen): The subprocess to terminate.\n        raise_nonzero_return (bool, optional): Whether to raise an exception\n            if the process returns a non-zero exit code. Defaults to True.\n\n    Raises:\n        subprocess.CalledProcessError: If the process returns a non-zero exit code\n            and raise_nonzero_return is True.\n    \"\"\"\n    stdout = None\n    stderr = None\n    while p.poll() is None:\n        try:\n            stdout, stderr = p.communicate(timeout=15)\n        except subprocess.TimeoutExpired:\n            if os.name == \"nt\":\n                p.send_signal(signal.CTRL_BREAK_EVENT)\n                p.send_signal(signal.CTRL_C_EVENT)\n            p.kill()\n    if p.returncode != 0 and raise_nonzero_return:\n        raise subprocess.CalledProcessError(returncode=p.returncode, cmd=p.args, output=stdout, stderr=stderr)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/curl_downloader/","title":"curl_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/curl_downloader/#cupang_downloader.downloaders.curl_downloader.CurlDownloader","title":"CurlDownloader","text":"<pre><code>CurlDownloader(\n    curl_bin=None, cancel_event=None, chunk_size=None\n)\n</code></pre> <p>               Bases: <code>DownloaderSubprocessMixin</code>, <code>DownloaderBase</code></p> <p>CurlDownloader uses <code>curl</code> to download files.</p> PARAMETER DESCRIPTION <code>curl_bin</code> <p>Path to the curl binary. Defaults to None.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\curl_downloader.py</code> <pre><code>def __init__(self, curl_bin: str | Path = None, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        curl_bin (str | Path, optional): Path to the curl binary. Defaults to None.\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.bin = self.check_bin(curl_bin or (\"curl\" if os.name != \"nt\" else \"curl.exe\"))\n    self.cmd = [str(self.bin), \"-sLo-\"]\n    self.opt = [\"--cacert\", str(default_cacert)]\n    super().__init__(cancel_event, chunk_size)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/curl_downloader/#cupang_downloader.downloaders.curl_downloader.CurlDownloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\curl_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_canceled:\n        return\n\n    with self.request(job.url, headers=job.headers) as res:\n        total = int(res.getheader(\"Content-Length\", 0))\n\n    cmd_headers = [f'-H \"{x}: {y}\"' for x, y in job.headers.items()]\n\n    with (\n        self.popen_wrapper(self.cmd + self.opt + cmd_headers + [job.url]) as p,\n        job.out.open(\"wb\") as f,\n    ):\n        downloaded = 0\n        while p.poll() is None and not self.is_canceled:\n            chunk = p.stdout.read(self.chunk_size)\n            if not chunk:\n                break\n            f.write(chunk)\n            downloaded += len(chunk)\n\n            self._handle_progress(progress_callback, job, total, downloaded)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/pycurl_downloader/","title":"pycurl_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/pycurl_downloader/#cupang_downloader.downloaders.pycurl_downloader.PycurlDownloader","title":"PycurlDownloader","text":"<pre><code>PycurlDownloader(cancel_event=None, chunk_size=None)\n</code></pre> <p>               Bases: <code>DownloaderBase</code></p> <p>PycurlDownloader uses <code>pycurl</code> module to download files.</p> PARAMETER DESCRIPTION <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __init__(self, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.cancel_event = cancel_event or Event()\n    self.chunk_size = chunk_size or 8192\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/pycurl_downloader/#cupang_downloader.downloaders.pycurl_downloader.PycurlDownloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\pycurl_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_canceled:\n        return\n\n    with self.request(job.url, headers=job.headers) as res:\n        total = res.getheader(\"Content-Length\", None)\n        if total is not None:\n            total = int(total)\n\n    callback_error: Exception = None\n\n    def _callback(_, d, *__):\n        try:\n            if self.is_canceled:\n                return 1\n\n            nonlocal callback_error\n            return self._handle_progress(progress_callback, job, total, d)\n        except (BaseException, Exception, KeyboardInterrupt) as e:\n            callback_error = e\n            return 1\n\n    with job.out.open(\"wb\") as f:\n        curl = pycurl.Curl()\n        curl.setopt(curl.URL, job.url)\n        curl.setopt(curl.WRITEDATA, f)\n        curl.setopt(curl.FOLLOWLOCATION, True)\n        curl.setopt(\n            curl.HTTPHEADER,\n            [f\"{k}: {v}\" for k, v in {**job.headers}.items()],\n        )\n        curl.setopt(curl.CAINFO, str(default_cacert))\n        curl.setopt(curl.BUFFERSIZE, self.chunk_size)\n        curl.setopt(curl.NOPROGRESS, False)\n        curl.setopt(\n            curl.XFERINFOFUNCTION,\n            _callback,\n        )\n\n        error = None\n        try:\n            curl.perform()\n        except Exception as e:\n            error = e\n        finally:\n            curl.close()\n\n        if callback_error is not None and not self.is_canceled:\n            raise callback_error.with_traceback(callback_error.__traceback__)\n\n        if error is not None and not self.is_canceled:\n            raise error.with_traceback(error.__traceback__)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/requests_downloader/","title":"requests_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/requests_downloader/#cupang_downloader.downloaders.requests_downloader.RequestsDownloader","title":"RequestsDownloader","text":"<pre><code>RequestsDownloader(cancel_event=None, chunk_size=None)\n</code></pre> <p>               Bases: <code>DownloaderBase</code></p> <p>RequestsDownloader uses <code>requests</code> module to download files.</p> PARAMETER DESCRIPTION <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __init__(self, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.cancel_event = cancel_event or Event()\n    self.chunk_size = chunk_size or 8192\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/requests_downloader/#cupang_downloader.downloaders.requests_downloader.RequestsDownloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\requests_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_cancelled:\n        return\n    with (\n        requests.get(\n            job.url,\n            headers=job.headers,\n            stream=True,\n            verify=str(default_cacert),\n        ) as res,\n        job.out.open(\"wb\") as f,\n    ):\n        res.raise_for_status()\n        total = int(res.getheader(\"Content-Length\", 0))\n\n        downloaded = 0\n        for chunk in res.iter_content(self.chunk_size):\n            if self.is_canceled:\n                break\n            if not chunk:\n                break\n            f.write(chunk)\n            downloaded += len(chunk)\n\n            self._handle_progress(progress_callback, job, total, downloaded)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/urllib_downloader/","title":"urllib_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/urllib_downloader/#cupang_downloader.downloaders.urllib_downloader.UrllibDownloader","title":"UrllibDownloader","text":"<pre><code>UrllibDownloader(cancel_event=None, chunk_size=None)\n</code></pre> <p>               Bases: <code>DownloaderBase</code></p> <p>UrllibDownloader uses built-in <code>urllib</code> module to download files.</p> PARAMETER DESCRIPTION <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\base.py</code> <pre><code>def __init__(self, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.cancel_event = cancel_event or Event()\n    self.chunk_size = chunk_size or 8192\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/urllib_downloader/#cupang_downloader.downloaders.urllib_downloader.UrllibDownloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\urllib_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_canceled:\n        return\n    with request(job.url, headers=job.headers) as res, job.out.open(\"wb\") as f:\n        total = int(res.getheader(\"Content-Length\", 0))\n\n        downloaded = 0\n        while not self.is_canceled:\n            chunk = res.read(self.chunk_size)\n            if not chunk:\n                break\n            f.write(chunk)\n            downloaded += len(chunk)\n\n            self._handle_progress(progress_callback, job, total, downloaded)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/wget_downloader/","title":"wget_downloader","text":""},{"location":"reference/cupang_downloader/downloaders/wget_downloader/#cupang_downloader.downloaders.wget_downloader.WgetDownloader","title":"WgetDownloader","text":"<pre><code>WgetDownloader(\n    wget_bin=None, cancel_event=None, chunk_size=None\n)\n</code></pre> <p>               Bases: <code>DownloaderSubprocessMixin</code>, <code>DownloaderBase</code></p> <p>WgetDownloader uses <code>wget</code> to download files.</p> PARAMETER DESCRIPTION <code>wget_bin</code> <p>Path to the wget binary. Defaults to None.</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>None</code> </p> <code>cancel_event</code> <p>Event to signal download cancellation. Defaults to None.</p> <p> TYPE: <code>Event</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>Size of each chunk to be downloaded. Defaults to None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Source code in <code>src\\cupang_downloader\\downloaders\\wget_downloader.py</code> <pre><code>def __init__(self, wget_bin: str | Path = None, cancel_event: Event = None, chunk_size: int = None) -&gt; None:\n    \"\"\"\n    Args:\n        wget_bin (str | Path, optional): Path to the wget binary. Defaults to None.\n        cancel_event (Event, optional): Event to signal download cancellation. Defaults to None.\n        chunk_size (int, optional): Size of each chunk to be downloaded. Defaults to None.\n    \"\"\"\n    self.bin = self.check_bin(wget_bin or (\"wget\" if os.name != \"nt\" else \"wget.exe\"))\n    self.cmd = [str(self.bin), \"-qO-\"]\n    self.opt = [\"--ca-certificate\", str(default_cacert)]\n    super().__init__(cancel_event, chunk_size)\n</code></pre>"},{"location":"reference/cupang_downloader/downloaders/wget_downloader/#cupang_downloader.downloaders.wget_downloader.WgetDownloader.download","title":"download","text":"<pre><code>download(job, progress_callback)\n</code></pre> <p>Execute the download process for a given job.</p> PARAMETER DESCRIPTION <code>job</code> <p>The download job containing details such as URL, headers, output destination, etc.</p> <p> TYPE: <code>DownloadJob</code> </p> <code>progress_callback</code> <p>A callback function to handle progress updates.</p> <p> TYPE: <code>Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]</code> </p> RAISES DESCRIPTION <code>BaseException</code> <p>Any exceptions related to the download process will be propagated as needed.</p> Source code in <code>src\\cupang_downloader\\downloaders\\wget_downloader.py</code> <pre><code>def download(\n    self,\n    job,\n    progress_callback,\n):\n    \"\"\"\n    Execute the download process for a given job.\n\n    Args:\n        job (DownloadJob): The download job containing details such as URL, headers, output destination, etc.\n        progress_callback (Callable[[DownloadJob, TotalInt, DownloadedInt, ExtraDict], None | Any]):\n            A callback function to handle progress updates.\n\n    Raises:\n        BaseException: Any exceptions related to the download process will be propagated as needed.\n    \"\"\"\n    if self.is_canceled:\n        return\n\n    with self.request(job.url, headers=job.headers) as res:\n        total = int(res.getheader(\"Content-Length\", 0))\n\n    cmd_headers = [f'--header=\"{x}: {y}\"' for x, y in job.headers.items()]\n\n    with self.popen_wrapper(self.cmd + self.opt + cmd_headers + [job.url]) as p, job.out.open(\"wb\") as f:\n        downloaded = 0\n        while p.poll() is None and not self.is_canceled:\n            chunk = p.stdout.read(self.chunk_size)\n            if not chunk:\n                break\n            f.write(chunk)\n            downloaded += len(chunk)\n\n            self._handle_progress(progress_callback, job, total, downloaded)\n</code></pre>"}]}